<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小大</title>
  
  <subtitle>群居守口，独处守心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.mrxiaoda.com/"/>
  <updated>2019-05-24T09:31:51.090Z</updated>
  <id>http://blog.mrxiaoda.com/</id>
  
  <author>
    <name>XiaoDa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AFNetworking源码解析</title>
    <link href="http://blog.mrxiaoda.com/2018/10/21/%5BiOS%5D%20AFNetworking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://blog.mrxiaoda.com/2018/10/21/[iOS] AFNetworking源码解析/</id>
    <published>2018-10-21T06:12:18.000Z</published>
    <updated>2019-05-24T09:31:51.090Z</updated>
    
    <content type="html"><![CDATA[<p>AFNetworking是iOS开发中常用的一个第三方网络库，可以说它是目前最流行的网络库，但其代码结构其实并不复杂，也可以说非常简洁优美。在AFNetworking中，大量使用的线程安全的开发技巧，读此源码也是一次很好的多线程学习机会。本篇博客从主要结构和网络请求的主流程进行分享，解析了AFNetworking的设计思路与工作原理，后面还有其中提供的UI扩展包的接口应用总结。</p><h2 id="一、-架构组成"><a href="#一、-架构组成" class="headerlink" title="一、 架构组成"></a>一、 架构组成</h2><p>AFNetworking可以分为五个模块：</p><ul><li>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)</li><li>网络状态监听模块(Reachability)</li><li>网络通信安全策略模块(Security)</li><li>网络通信信息序列化/反序列化模块(Serialization)</li><li>对于iOS UIKit库的扩展(UIKit)</li></ul><p>对于AFNetworking框架的核心，无非AFURLSesstionManager类，这个类是基于系统的NSURLSesstion会话类进行的管理者包装，下图是AF框架一个整体的结构。</p><p><img src="/img/AFNetworking/AFNetworking.png" alt="AFNetworking"></p><h2 id="二、-核心类解析"><a href="#二、-核心类解析" class="headerlink" title="二、 核心类解析"></a>二、 核心类解析</h2><h3 id="1、网络通信模块"><a href="#1、网络通信模块" class="headerlink" title="1、网络通信模块"></a>1、网络通信模块</h3><h5 id="1-1-AFURLSesstionManager"><a href="#1-1-AFURLSesstionManager" class="headerlink" title="1.1 AFURLSesstionManager"></a>1.1 AFURLSesstionManager</h5><h6 id="1-1-1-初始化方法"><a href="#1-1-1-初始化方法" class="headerlink" title="1.1.1  初始化方法"></a>1.1.1  初始化方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!configuration) &#123;</span><br><span class="line">      //使用默认配置</span><br><span class="line">      configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.sessionConfiguration = configuration;</span><br><span class="line"></span><br><span class="line">  //queue并发线程数设置为1</span><br><span class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    self.operationQueue.maxConcurrentOperationCount = 1;</span><br><span class="line">  </span><br><span class="line">//创建session会话</span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br><span class="line"></span><br><span class="line">  //默认将返回数据按照json进行解析</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">  //设置安全验证</span><br><span class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">#if !TARGET_OS_WATCH</span><br><span class="line">  //设置网络状态监听</span><br><span class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">#endif</span><br><span class="line">    // 设置存储NSURL task与AFURLSessionManagerTaskDelegate的词典（重点，在AF中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理） </span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</span><br><span class="line"></span><br><span class="line">  //初始化锁</span><br><span class="line">    self.lock = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">    self.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">//下面的做法是为了防止 被修改了sesstion的系统实现有初始任务</span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</span><br><span class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</span><br><span class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</span><br><span class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</span><br><span class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个需要注意的地方就是 self.operationQueue.maxConcurrentOperationCount = 1;</p><p>NSURLConnention 的一个弊端就是：在发起请求之后，这条线程并不能释放，而是需要一直处于保活状态去等待回调。NSURLSession就是为了替代NSURLConnection而出现的，NSURLSession的其他优点这里不作赘述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//queue并发线程数设置为1</span><br><span class="line">self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">self.operationQueue.maxConcurrentOperationCount = 1;</span><br><span class="line">//创建session会话</span><br><span class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br></pre></td></tr></table></figure><p>从上述代码中我们可以看出NSURLSession不在需要在当前线程进行代理方法的回调，可以指定回调的delegateQueue，区别于AF2.x，我们不在需要为了等待代理回调去保活线程。</p><p>同时也需要注意这里设置的 maxConcurrentOperationCount 为1，主要是想让并发的请求进行串行回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = nil;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    //给所要访问的资源加锁，防止造成数据混乱</span><br><span class="line">    delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">    return delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边对 self.mutableTaskDelegatesKeyedByTaskIdentifier 的访问进行了加锁，目的是保证多线程环境下的数据安全。既然加了锁，就算maxConcurrentOperationCount不设为1，当某个请求正在回调时，下一个请求还是得等待一直到上个请求获取完所要的资源后解锁，所以这边并发回调也是没有意义的。相反多task回调导致的多线程并发，还会导致性能的浪费。</p><h6 id="1-1-2-创建请求"><a href="#1-1-2-创建请求" class="headerlink" title="1.1.2  创建请求"></a>1.1.2  创建请求</h6><p>AFURLSesstionManager创建的请求任务有三类，分别对应了NSURLSession中的NSURLSessionDataTask，NSURLSessionUploadTask以及NSURLSessionDownloadTask。</p><p>以数据请求为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        //创建任务</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line">    //进行代理设置</span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对代理进行设置</span><br><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    //创建内部代理</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">    delegate.manager = self;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    //设置代理 </span><br><span class="line">    [self setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的NSURLSesstionTask代理其实还是AFURLSesstionManager本身，manager收到回调之后会自己处理一些回调，与开发者相关的回调会转给AFURLSessionManagerTaskDelegate处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">//接收到URL重定向时回调</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">willPerformHTTPRedirection:(NSHTTPURLResponse *)response</span><br><span class="line">        newRequest:(NSURLRequest *)request</span><br><span class="line"> completionHandler:(void (^)(NSURLRequest *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLRequest *redirectRequest = request;</span><br><span class="line">    //这里会执行用户自定义的重定向block</span><br><span class="line">    if (self.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line">    //继续重定向后的请求</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//接收到安全认证挑战的回调</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line">    //如果开发者有提供block 交开发者处理 否则用默认的安全验证方案处理</span><br><span class="line">    if (self.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//需要提供数据流传向服务器时调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line"> needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSInputStream *inputStream = nil;</span><br><span class="line"></span><br><span class="line">    if (self.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = self.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream copy];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//已经发送数据后调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int64_t totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line">    if(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123;</span><br><span class="line">        NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@&quot;Content-Length&quot;];</span><br><span class="line">        if(contentLength) &#123;</span><br><span class="line">            totalUnitCount = (int64_t) [contentLength longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.taskDidSendBodyData) &#123;</span><br><span class="line">        self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//请求任务完成时回调</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    //拿到内部代理 交给它处理</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    // delegate may be nil when completing a task in the background</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line"></span><br><span class="line">        [self removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//接收到返回数据时回调</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</span><br><span class="line"></span><br><span class="line">    if (self.dataTaskDidReceiveResponse) &#123;</span><br><span class="line">        disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//此请求将要变更成下载任务时回调</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">&#123;   </span><br><span class="line">    //重新设置内部代理</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        [self removeDelegateForTask:dataTask];</span><br><span class="line">        [self setDelegate:delegate forTask:downloadTask];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.dataTaskDidBecomeDownloadTask) &#123;</span><br><span class="line">        self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//开始获取数据时调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    //交给内部代理处理</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line"></span><br><span class="line">    if (self.dataTaskDidReceiveData) &#123;</span><br><span class="line">        self.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//将要缓存回执数据时调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line"> willCacheResponse:(NSCachedURLResponse *)proposedResponse</span><br><span class="line"> completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSCachedURLResponse *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    if (self.dataTaskWillCacheResponse) &#123;</span><br><span class="line">        cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//下载任务结束后回调</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];</span><br><span class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        if (fileURL) &#123;</span><br><span class="line">            delegate.downloadFileURL = fileURL;</span><br><span class="line">            NSError *error = nil;</span><br><span class="line">            //数据位置移动</span><br><span class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     //内部代理进行后续处理</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AFURLSesstionManagerTaskDelegate是一个内部类，主要用来处理AFURLSesstionManager转过来的一些网络回调，请求进度的控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">//接收到数据后 将数据进行拼接</span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</span><br><span class="line">    didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    [self.mutableData appendData:data];</span><br><span class="line">&#125;</span><br><span class="line">//请求完成后</span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">    __strong AFURLSessionManager *manager = self.manager;</span><br><span class="line"></span><br><span class="line">    __block id responseObject = nil;</span><br><span class="line">    //配置一个信息字典</span><br><span class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line">    //拿到请求结果数据</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if (self.mutableData) &#123;</span><br><span class="line">        data = [self.mutableData copy];</span><br><span class="line">        //We no longer need the reference, so nil it out to gain back some memory.</span><br><span class="line">        self.mutableData = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //下载信息配置</span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</span><br><span class="line">    &#125; else if (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    //错误信息配置</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (self.completionHandler) &#123;</span><br><span class="line">                self.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line">            //用回执数据序列化类进行数据处理</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            if (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                if (self.completionHandler) &#123;</span><br><span class="line">                    self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//下载处理</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    NSError *fileManagerError = nil;</span><br><span class="line">    self.downloadFileURL = nil;</span><br><span class="line"></span><br><span class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        if (self.downloadFileURL) &#123;</span><br><span class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            if (fileManagerError) &#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-AFHTTPSessionManager"><a href="#1-2-AFHTTPSessionManager" class="headerlink" title="1.2 AFHTTPSessionManager"></a>1.2 AFHTTPSessionManager</h5><p>AFHTTPSessionManager主要是对AFURLSessionManager的封装，是开发人员经常调用的一个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@interface AFHTTPSessionManager : AFURLSessionManager &lt;NSSecureCoding, NSCopying</span><br><span class="line">//基础URL</span><br><span class="line">@property (readonly, nonatomic, strong, nullable) NSURL *baseURL;</span><br><span class="line">//请求序列化对象</span><br><span class="line">@property (nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</span><br><span class="line">//回执序列化对象</span><br><span class="line">@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</span><br><span class="line">//创建一个默认的Manager实例  注意不是单例</span><br><span class="line">+ (instancetype)manager;</span><br><span class="line">//初始化方法</span><br><span class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url;</span><br><span class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url</span><br><span class="line">           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</span><br><span class="line">//进行get请求</span><br><span class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</span><br><span class="line">                   parameters:(nullable id)parameters</span><br><span class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</span><br><span class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</span><br><span class="line">                            parameters:(nullable id)parameters</span><br><span class="line">                              progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress</span><br><span class="line">                               success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</span><br><span class="line">                               failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</span><br><span class="line"></span><br><span class="line">//进行HEAD请求</span><br><span class="line">- (nullable NSURLSessionDataTask *)HEAD:(NSString *)URLString</span><br><span class="line">                    parameters:(nullable id)parameters</span><br><span class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task))success</span><br><span class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</span><br><span class="line"></span><br><span class="line">//进行POST请求</span><br><span class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</span><br><span class="line">                    parameters:(nullable id)parameters</span><br><span class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</span><br><span class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</span><br><span class="line">                             parameters:(nullable id)parameters</span><br><span class="line">                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress</span><br><span class="line">                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</span><br><span class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</span><br><span class="line">                    parameters:(nullable id)parameters</span><br><span class="line">     constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</span><br><span class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</span><br><span class="line">                             parameters:(nullable id)parameters</span><br><span class="line">              constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress</span><br><span class="line">                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</span><br><span class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</span><br><span class="line"></span><br><span class="line">//进行PUT请求</span><br><span class="line">- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString</span><br><span class="line">                   parameters:(nullable id)parameters</span><br><span class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</span><br><span class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</span><br><span class="line"></span><br><span class="line">//进行PATCH请求</span><br><span class="line">- (nullable NSURLSessionDataTask *)PATCH:(NSString *)URLString</span><br><span class="line">                     parameters:(nullable id)parameters</span><br><span class="line">                        success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</span><br><span class="line">                        failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</span><br><span class="line"></span><br><span class="line">//进行DELETE请求</span><br><span class="line">- (nullable NSURLSessionDataTask *)DELETE:(NSString *)URLString</span><br><span class="line">                      parameters:(nullable id)parameters</span><br><span class="line">                         success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</span><br><span class="line">                         failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</span><br></pre></td></tr></table></figure><h3 id="2、序列化"><a href="#2、序列化" class="headerlink" title="2、序列化"></a>2、序列化</h3><p>AFNetworking中的序列化是两个协议，他们的作用其实就是对请求进行配置以及对返回数据进行解析。</p><h5 id="2-1-AFURLRequestSerialization"><a href="#2-1-AFURLRequestSerialization" class="headerlink" title="2.1 AFURLRequestSerialization"></a>2.1 AFURLRequestSerialization</h5><p>实现这个接口的类主要是AFHTTPRequestSerizlizaer类，其还有两个子类，分别为AFJSONRequestSerizlizaer和AFPropertyListRequestSerializer类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol AFURLResponseSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;</span><br><span class="line">//将请求和参数进行配置后返回</span><br><span class="line">- (nullable id)responseObjectForResponse:(nullable NSURLResponse *)response</span><br><span class="line">                           data:(nullable NSData *)data</span><br><span class="line">                          error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;</span><br></pre></td></tr></table></figure><p>AFHTTPRequestSerizlizaer在请求的时候会对请求的head进行配置，他默认会向请求头中添加Accept-Language，User-Agent以及其他可配置的头部信息(缓存，Cookie，超时时间，用户名密码等)。在进行请求参数配置的时候，AFHTTPRequestSerizlizaer会根据请求方法来选择配置到url后面或者添加到请求body中(HEAD，DELETE，GET会追加URL，其他添加body)。AFJSONRequestSerizlizaer的作用与AFHTTPRequestSerizlizaer一致，不同的是会将请求头中的Content-Type设置为application/json并且将参数格式化成JSON数据放置在请求体中，AFPropertyListRequestSerializer类则是将Content-Type设置为application/x-plist，并且将参数格式化成Plist数据放入请求体。</p><h5 id="2-2-AFURLResponseSerialization"><a href="#2-2-AFURLResponseSerialization" class="headerlink" title="2.2 AFURLResponseSerialization"></a>2.2 AFURLResponseSerialization</h5><p>实现这个协议的类主要是AFHTTPResponseSerializer类，它的子类分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AFJSONResponseSerializer//用来解析返回数据为JSON数据的回执,MIMEType必须为application/json，text/json或text/javascript</span><br><span class="line"></span><br><span class="line">AFXMLParserResponseSerializer//用来解析XML数据，其会返回一个XML解析器，使用它时，返回头信息中的MIMEType必须为application/xml或text/xml</span><br><span class="line"></span><br><span class="line">AFXMLDocumentResponseSerializer//将数据解析成XML文档</span><br><span class="line"></span><br><span class="line">AFPropertyListResponseSerializer//将返回数据解析成Plist数据</span><br><span class="line"></span><br><span class="line">AFImageResponseSerializer//将返回数据解析成UIImage图片，其支持的MIMEType类型为image/tiff，image/jpeg，image/gif，image/png，image/ico，image/x-icon，image/bmp，image/x-bmp，image/x-xbitmap，image/x-win-bitmap</span><br><span class="line"></span><br><span class="line">AFCompoundResponseSerializer//这个类示例中可以配置多个ResponseSerializer实例，解析的时候会进行遍历尝试找到可以解析的模式，这种模式也叫混合解析模式</span><br></pre></td></tr></table></figure><h3 id="3、网络安全策略"><a href="#3、网络安全策略" class="headerlink" title="3、网络安全策略"></a>3、网络安全策略</h3><p>AFSecurityPolicy这个类，AF就是用这个类来满足我们各种https认证需求的。</p><p>在AFURLSessionManager中发送网络请求收到认证挑战时，会进入以下回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    //挑战处理类型为 默认</span><br><span class="line">    /*</span><br><span class="line">     NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理</span><br><span class="line">     NSURLSessionAuthChallengeUseCredential：使用指定的证书</span><br><span class="line">     NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战</span><br><span class="line">     */</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    // sessionDidReceiveAuthenticationChallenge是自定义方法，用来如何应对服务器端的认证挑战</span><br><span class="line"></span><br><span class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">         // 此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust</span><br><span class="line">        // 也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。</span><br><span class="line">       </span><br><span class="line">        // 而这个证书就需要使用credentialForTrust:来创建一个NSURLCredential对象</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            </span><br><span class="line">            // 基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                // 创建挑战证书（注：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书）</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                // 确定挑战的方式</span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    //证书挑战  设计policy,none，则跑到这里</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //取消挑战</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //默认挑战方式</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //完成挑战</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的回调中执行了AFSecurityPolicy相关的一个方法，做了一个AF内部的一个https认证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]</span><br></pre></td></tr></table></figure><p>这里securityPolicy存在的作用就是，使得在系统底层自己去验证之前，AF可以先去验证服务端的证书。如果通不过，则直接越过系统的验证，取消https的网络请求。否则，继续去走系统根证书的验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">//验证服务端是否值得信任</span><br><span class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(NSString *)domain</span><br><span class="line">&#123;</span><br><span class="line">    //判断矛盾的条件</span><br><span class="line">    //判断有域名，且允许自建证书，需要验证域名，</span><br><span class="line">    //因为要验证域名，所以必须不能是后者两种：AFSSLPinningModeNone或者添加到项目里的证书为0个。</span><br><span class="line">    if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;</span><br><span class="line">        // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span><br><span class="line">        //  According to the docs, you should only trust your provided certs for evaluation.</span><br><span class="line">        //  Pinned certificates are added to the trust. Without pinned certificates,</span><br><span class="line">        //  there is nothing to evaluate against.</span><br><span class="line">        //</span><br><span class="line">        //  From Apple Docs:</span><br><span class="line">        //          &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span><br><span class="line">        //           Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot;</span><br><span class="line">        NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);</span><br><span class="line">        //不受信任，返回</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //用来装验证策略</span><br><span class="line">    NSMutableArray *policies = [NSMutableArray array];</span><br><span class="line">    //要验证域名</span><br><span class="line">    if (self.validatesDomainName) &#123;</span><br><span class="line">        </span><br><span class="line">        // 如果需要验证domain，那么就使用SecPolicyCreateSSL函数创建验证策略，其中第一个参数为true表示验证整个SSL证书链，第二个参数传入domain，用于判断整个证书链上叶子节点表示的那个domain是否和此处传入domain一致</span><br><span class="line">        //添加验证策略</span><br><span class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果不需要验证domain，就使用默认的BasicX509验证策略</span><br><span class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //serverTrust：X。509服务器的证书信任。</span><br><span class="line">    // 为serverTrust设置验证策略，即告诉客户端如何验证serverTrust</span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    //有验证策略了，可以去验证了。如果是AFSSLPinningModeNone，是自签名，直接返回可信任，否则不是自签名的就去系统根证书里去找是否有匹配的证书。</span><br><span class="line">    if (self.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        //如果支持自签名，直接返回YES,不允许才去判断第二个条件，判断serverTrust是否有效</span><br><span class="line">        return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果验证无效AFServerTrustIsValid，而且allowInvalidCertificates不允许自签，返回NO</span><br><span class="line">    else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断SSLPinningMode</span><br><span class="line">    switch (self.SSLPinningMode) &#123;</span><br><span class="line">        // 理论上，上面那个部分已经解决了self.SSLPinningMode)为AFSSLPinningModeNone)等情况，所以此处再遇到，就直接返回NO</span><br><span class="line">        case AFSSLPinningModeNone:</span><br><span class="line">        default:</span><br><span class="line">            return NO;</span><br><span class="line">        </span><br><span class="line">        //验证证书类型</span><br><span class="line">        case AFSSLPinningModeCertificate: &#123;</span><br><span class="line">            </span><br><span class="line">            NSMutableArray *pinnedCertificates = [NSMutableArray array];</span><br><span class="line">            </span><br><span class="line">            //把证书data，用系统api转成 SecCertificateRef 类型的数据,SecCertificateCreateWithData函数对原先的pinnedCertificates做一些处理，保证返回的证书都是DER编码的X.509证书</span><br><span class="line"></span><br><span class="line">            for (NSData *certificateData in self.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">            // 将pinnedCertificates设置成需要参与验证的Anchor Certificate（锚点证书，通过SecTrustSetAnchorCertificates设置了参与校验锚点证书之后，假如验证的数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书），具体就是调用SecTrustEvaluate来验证。</span><br><span class="line">            //serverTrust是服务器来的验证，有需要被验证的证书。</span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            //自签在之前是验证通过不了的，在这一步，把我们自己设置的证书加进去之后，就能验证成功了。</span><br><span class="line">            </span><br><span class="line">            //再去调用之前的serverTrust去验证该证书是否有效，有可能：经过这个方法过滤后，serverTrust里面的pinnedCertificates被筛选到只有信任的那一个证书</span><br><span class="line">            if (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&apos;s the Root CA)</span><br><span class="line">            //注意，这个方法和我们之前的锚点证书没关系了，是去从我们需要被验证的服务端证书，去拿证书链。</span><br><span class="line">            // 服务器端的证书链，注意此处返回的证书链顺序是从叶节点到根节点</span><br><span class="line">            NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line">            //reverseObjectEnumerator逆序</span><br><span class="line">            for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                </span><br><span class="line">                //如果我们的证书中，有一个和它证书链中的证书匹配的，就返回YES</span><br><span class="line">                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    return YES;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //没有匹配的</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">            //公钥验证 AFSSLPinningModePublicKey模式同样是用证书绑定(SSL Pinning)方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</span><br><span class="line">        case AFSSLPinningModePublicKey: &#123;</span><br><span class="line">            </span><br><span class="line">            NSUInteger trustedPublicKeyCount = 0;</span><br><span class="line">            </span><br><span class="line">            // 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥</span><br><span class="line">            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            //遍历服务端公钥</span><br><span class="line">            for (id trustChainPublicKey in publicKeys) &#123;</span><br><span class="line">                //遍历本地公钥</span><br><span class="line">                for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;</span><br><span class="line">                    //判断如果相同 trustedPublicKeyCount+1</span><br><span class="line">                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return trustedPublicKeyCount &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是<code>AFSecurityPolicy</code>最核心的方法，其他的都是为了配合这个方法。这个方法完成了服务端的证书的信任评估。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AFNetworking是iOS开发中常用的一个第三方网络库，可以说它是目前最流行的网络库，但其代码结构其实并不复杂，也可以说非常简洁优美。在AFNetworking中，大量使用的线程安全的开发技巧，读此源码也是一次很好的多线程学习机会。本篇博客从主要结构和网络请求的主流程
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.mrxiaoda.com/categories/iOS/"/>
    
    
      <category term="AFNetworking" scheme="http://blog.mrxiaoda.com/tags/AFNetworking/"/>
    
  </entry>
  
  <entry>
    <title>WKWebView的那些坑</title>
    <link href="http://blog.mrxiaoda.com/2018/09/24/%5BiOS%5D%20WKWebView%E9%81%87%E5%88%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://blog.mrxiaoda.com/2018/09/24/[iOS] WKWebView遇到的那些坑/</id>
    <published>2018-09-24T13:06:27.000Z</published>
    <updated>2018-10-24T14:24:05.992Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇文章中介绍了WKWebView的一下常用属性以及常用API，那么在这篇文章中将主要讲述WKWebView在使用过程中遇到的一些坑。</p><h2 id="1-白屏问题"><a href="#1-白屏问题" class="headerlink" title="1.白屏问题"></a>1.白屏问题</h2><p>在UIWebView上个当内存占用太大时，app会直接crash，而在WKWebView上内存占用太大时，WebContent Process 会 crash，从而导致页面白屏。</p><p><strong>解决办法：</strong></p><p>在iOS9之后WKNavigtionDelegate 新增了一个回调函数：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>webViewWebContentProcessDidTerminate:<span class="params">(WKWebView *)</span>webView;</span><br></pre></td></tr></table></figure><p>在WebContent Process即将crash的时候，系统会调用上面的函数，这个时候webView.URL还不为空，所以我们直接在上面的这个回调里面调用[webView reload]，问题得到解决。</p><h2 id="2-双击页面导致客户端崩溃问题"><a href="#2-双击页面导致客户端崩溃问题" class="headerlink" title="2.双击页面导致客户端崩溃问题"></a>2.双击页面导致客户端崩溃问题</h2><p><strong>报错信息：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WKContentView isSecureTextEntry]: unrecognized selector sent <span class="keyword">to</span><span class="built_in"> instance </span>0x101bd5000</span><br></pre></td></tr></table></figure><p>从这个报错信息表明<strong>WKContentView</strong>没有找到<strong>isSecureTextEntry</strong>方法，在查找各种资料无果后决定用runtime的方式给<strong>WKContentView</strong>加上该方法，简单粗暴。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)progressWKContentViewCrash </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] doubleValue] &gt;= <span class="number">8.0</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *className = <span class="string">@"WKContentView"</span>.UTF8String;</span><br><span class="line"></span><br><span class="line">        Class <span class="built_in">WKContentViewClass</span> = objc_getClass(className);</span><br><span class="line"></span><br><span class="line">        SEL isSecureTextEntry = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"isSecureTextEntry"</span>);</span><br><span class="line"></span><br><span class="line">        SEL secureTextEntry = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"secureTextEntry"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BOOL</span> addIsSecureTextEntry = class_addMethod(<span class="built_in">WKContentViewClass</span>, isSecureTextEntry, (IMP)isSecureTextEntryIMP, <span class="string">"B@:"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BOOL</span> addSecureTextEntry = class_addMethod(<span class="built_in">WKContentViewClass</span>, secureTextEntry, (IMP)secureTextEntryIMP, <span class="string">"B@:"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!addIsSecureTextEntry || !addSecureTextEntry) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"WKContentView-Crash-&gt;修复失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 实现WKContentView对象isSecureTextEntry方法</span></span><br><span class="line"><span class="comment"> @return NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">BOOL</span> isSecureTextEntryIMP(<span class="keyword">id</span> sender, SEL cmd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 实现WKContentView对象secureTextEntry方法</span></span><br><span class="line"><span class="comment"> @return NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">BOOL</span> secureTextEntryIMP(<span class="keyword">id</span> sender, SEL cmd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上progressWKContentViewCrash方法只需要调用一次即可，无需多次调用。</p><h2 id="3-页面无法释放问题"><a href="#3-页面无法释放问题" class="headerlink" title="3.页面无法释放问题"></a>3.页面无法释放问题</h2><p>在实际使用过程当中，发现使用了WKWebView的界面始终无法释放，在排除了其他因素之后，把目光转向了WKWebView。经过排查之后发现，在初始化webview的时候是这样的：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">webview</span> = [[WKWebView alloc]initWithFrame:frame configuration:configuration];</span><br></pre></td></tr></table></figure><p>然而webview为了与js进行交互，configuration的userContentController属性添加了一个WKScriptMessageHandler：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[configuration.userContentController <span class="string">addScriptMessageHandler:</span>self <span class="string">name:</span>@<span class="string">"methodName"</span>];</span><br></pre></td></tr></table></figure><p>因为webview的持有者是controller，然后controller又被configuration.userContentController强引用，所以导致页面无法释放。所以这里建议将handler设置成一个管理类，并且在页面的delloc中将其移除。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[configuration.userContentController <span class="string">addScriptMessageHandler:</span>handlerManager <span class="string">name:</span>@<span class="string">"methodName"</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [webview.configuration.userContentController <span class="string">removeScriptMessageHandlerForName:</span>@<span class="string">"AppNestCall"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Alert相关问题"><a href="#4-Alert相关问题" class="headerlink" title="4.Alert相关问题"></a>4.Alert相关问题</h2><h4 id="4-1、Js执行alert方法不弹出alert问题"><a href="#4-1、Js执行alert方法不弹出alert问题" class="headerlink" title="4.1、Js执行alert方法不弹出alert问题"></a>4.1、Js执行alert方法不弹出alert问题</h4><p>首先确定webview的回调中已经实现了alert，然后在判断alert弹出时是否有其他界面正在弹出或消失，若有，则在动画结束之后再弹出alert。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)<span class="string">webView:</span>(WKWebView *)webView <span class="string">runJavaScriptAlertPanelWithMessage:</span>(NSString *)message <span class="string">initiatedByFrame:</span>(WKFrameInfo *)frame <span class="string">completionHandler:</span>(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler；</span><br></pre></td></tr></table></figure><h4 id="4-2、Alert崩溃问题"><a href="#4-2、Alert崩溃问题" class="headerlink" title="4.2、Alert崩溃问题"></a>4.2、Alert崩溃问题</h4><p>确保最后的completionHandler被执行。</p><h2 id="5、其它问题"><a href="#5、其它问题" class="headerlink" title="5、其它问题"></a>5、其它问题</h2><h4 id="5-1、视频自动播放"><a href="#5-1、视频自动播放" class="headerlink" title="5.1、视频自动播放"></a>5.1、视频自动播放</h4><p>WKWebView 需要通过WKWebViewConfiguration.mediaPlaybackRequiresUserAction设置是否允许自动播放，但一定要在 WKWebView 初始化之前设置，在 WKWebView 初始化之后设置无效。</p><h4 id="5-2、goBack-API问题"><a href="#5-2、goBack-API问题" class="headerlink" title="5.2、goBack API问题"></a>5.2、goBack API问题</h4><p>WKWebView 上调用 -[WKWebView goBack], 回退到上一个页面后不会触发window.onload()函数、不会执行JS。</p><h4 id="5-3、页面滚动速率"><a href="#5-3、页面滚动速率" class="headerlink" title="5.3、页面滚动速率"></a>5.3、页面滚动速率</h4><p>WKWebView 需要通过scrollView delegate调整滚动速率：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="keyword">scrollViewWillBeginDragging:(UIScrollView </span>*)<span class="keyword">scrollView </span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">scrollView.decelerationRate </span>= UIScrollViewDecelerationRateNormal<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一篇文章中介绍了WKWebView的一下常用属性以及常用API，那么在这篇文章中将主要讲述WKWebView在使用过程中遇到的一些坑。&lt;/p&gt;
&lt;h2 id=&quot;1-白屏问题&quot;&gt;&lt;a href=&quot;#1-白屏问题&quot; class=&quot;headerlink&quot; title=&quot;1.白屏
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.mrxiaoda.com/categories/iOS/"/>
    
    
      <category term="WKWebView" scheme="http://blog.mrxiaoda.com/tags/WKWebView/"/>
    
  </entry>
  
  <entry>
    <title>WKWebView的常用属性以及常用API</title>
    <link href="http://blog.mrxiaoda.com/2018/09/19/%5BiOS%5D%20WKWebView%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8API/"/>
    <id>http://blog.mrxiaoda.com/2018/09/19/[iOS] WKWebView的常用属性以及常用API/</id>
    <published>2018-09-19T15:43:32.000Z</published>
    <updated>2018-10-24T13:16:26.987Z</updated>
    
    <content type="html"><![CDATA[<p>从WKWebView的推出到现在，相信大家很已经了解了它相对于UIWebView的优势，加载速度快，占用内存低同时也解决了内存泄漏的问题，所以现在绝大多数的项目都已经使用了WKWebView来替代UIWebView，本文主要是对WKWebView的一些常用属性一集常用API来讲解。</p><h2 id="1-WKWebView"><a href="#1-WKWebView" class="headerlink" title="1. WKWebView"></a>1. WKWebView</h2><h3 id="1-1-WKWebView主要涉及的类："><a href="#1-1-WKWebView主要涉及的类：" class="headerlink" title="1.1 WKWebView主要涉及的类："></a>1.1 WKWebView主要涉及的类：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebView</span>                  <span class="comment">//网页的渲染与展示</span></span><br><span class="line"><span class="built_in">WKWebViewConfiguration</span>     <span class="comment">//这个类用于网页的配置</span></span><br><span class="line"><span class="built_in">WKUserScript</span>               <span class="comment">//用于往加载的页面中添加额外需要执行的JavaScript代码</span></span><br><span class="line"><span class="built_in">WKUserContentController</span>    <span class="comment">//用户原生与JavaScript交互</span></span><br><span class="line"><span class="built_in">WKWebsiteDataStore</span>         <span class="comment">//这个类在处理缓存的时候用到</span></span><br></pre></td></tr></table></figure><h3 id="1-2-WKWebView主要涉及的代理"><a href="#1-2-WKWebView主要涉及的代理" class="headerlink" title="1.2 WKWebView主要涉及的代理"></a>1.2 WKWebView主要涉及的代理</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKNavigationDelegate</span>        <span class="comment">//网页跳转间的导航管理协议，这个协议可以监听网页的活动</span></span><br><span class="line"><span class="built_in">WKUIDelegate</span>                <span class="comment">//用于交互处理JavaScript中的一些弹出框</span></span><br></pre></td></tr></table></figure><h3 id="1-3-WKWebView的一些常用属性"><a href="#1-3-WKWebView的一些常用属性" class="headerlink" title="1.3 WKWebView的一些常用属性"></a>1.3 WKWebView的一些常用属性</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导航代理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;<span class="built_in">WKNavigationDelegate</span>&gt; navigationDelegate;</span><br><span class="line"><span class="comment">// UI代理</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;<span class="built_in">WKUIDelegate</span>&gt; <span class="built_in">UIDelegate</span>;</span><br><span class="line"><span class="comment">// 页面标题, 一般使用KVO动态获取</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="comment">// 页面加载进度, 一般使用KVO动态获取</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">double</span> estimatedProgress;</span><br><span class="line"><span class="comment">// 可返回的页面列表, 已打开过的网页, 有点类似于navigationController的viewControllers属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">WKBackForwardList</span> *backForwardList;</span><br><span class="line"><span class="comment">// 页面url</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *URL;</span><br><span class="line"><span class="comment">// 页面是否在加载中</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isLoading) <span class="built_in">BOOL</span> loading;</span><br><span class="line"><span class="comment">// 是否可返回</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> canGoBack;</span><br><span class="line"><span class="comment">// 是否可向前</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> canGoForward;</span><br><span class="line"><span class="comment">// WKWebView继承自UIView, 所以如果想设置scrollView的一些属性, 需要对此属性进行配置</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"><span class="comment">// 是否允许手势左滑返回上一级, 类似导航控制的左滑返回</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> allowsBackForwardNavigationGestures;</span><br><span class="line"><span class="comment">//自定义UserAgent, 会覆盖默认的值 ,iOS 9之后有效</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *customUserAgent</span><br></pre></td></tr></table></figure><h3 id="1-4-WKWebView的一些常用方法"><a href="#1-4-WKWebView的一些常用方法" class="headerlink" title="1.4 WKWebView的一些常用方法"></a>1.4 WKWebView的一些常用方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带配置信息的初始化方法,configuration 配置信息</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame configuration:(<span class="built_in">WKWebViewConfiguration</span> *)configuration</span><br><span class="line"><span class="comment">// 加载请求</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)loadRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"><span class="comment">// 加载HTML</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)loadHTMLString:(<span class="built_in">NSString</span> *)string baseURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)baseURL;</span><br><span class="line"><span class="comment">// 返回上一级</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)goBack;</span><br><span class="line"><span class="comment">// 前进下一级, 需要曾经打开过, 才能前进</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)goForward;</span><br><span class="line"><span class="comment">// 刷新页面</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)reload;</span><br><span class="line"><span class="comment">// 根据缓存有效期来刷新页面</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)reloadFromOrigin;</span><br><span class="line"><span class="comment">// 停止加载页面</span></span><br><span class="line">- (<span class="keyword">void</span>)stopLoading;</span><br><span class="line"><span class="comment">// 执行JavaScript代码</span></span><br><span class="line">- (<span class="keyword">void</span>)evaluateJavaScript:(<span class="built_in">NSString</span> *)javaScriptString completionHandler:(<span class="keyword">void</span> (^ _Nullable)(_Nullable <span class="keyword">id</span>, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br></pre></td></tr></table></figure><h3 id="2-WKWebViewConfiguration的常用属性"><a href="#2-WKWebViewConfiguration的常用属性" class="headerlink" title="2. WKWebViewConfiguration的常用属性"></a>2. WKWebViewConfiguration的常用属性</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过此属性来执行JavaScript代码来修改页面的行为</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) WKUserContentController *userContentController;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***********下面属性一般不需要设置</span></span><br><span class="line"><span class="comment">// 首选项设置,  </span></span><br><span class="line"><span class="comment">//可设置最小字号, 是否允许执行js</span></span><br><span class="line"><span class="comment">//是否通过js自动打开新的窗口</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) WKPreferences *preferences;</span><br><span class="line"><span class="comment">// 是否允许播放媒体文件</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic) BOOL allowsAirPlayForMediaPlayback</span><br><span class="line"><span class="comment">// 需要用户来操作才能播放的多媒体类型</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic) WKAudiovisualMediaTypes mediaTypesRequiringUserActionForPlayback</span><br><span class="line"><span class="comment">// 是使用h5的视频播放器在线播放, 还是使用原生播放器全屏播放</span></span><br><span class="line"><span class="variable">@property</span> (nonatomic) BOOL allowsInlineMediaPlayback;</span><br></pre></td></tr></table></figure><h3 id="3-WKUserScript"><a href="#3-WKUserScript" class="headerlink" title="3.WKUserScript"></a>3.WKUserScript</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"><span class="title">js</span>与原生交互主要依靠的类</span><br><span class="line"></span><br><span class="line"><span class="title">source</span>: 需要执行的<span class="type">JavaScript</span>代码</span><br><span class="line"><span class="title">injectionTime</span>: 加入的位置, 是一个枚举</span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">WKUserScriptInjectionTime</span>) &#123;</span><br><span class="line">    <span class="type">WKUserScriptInjectionTimeAtDocumentStart</span>,</span><br><span class="line">    <span class="type">WKUserScriptInjectionTimeAtDocumentEnd</span></span><br><span class="line">&#125; <span class="type">API_AVAILABLE</span>(macosx(10.10), ios(8.0));</span><br><span class="line"></span><br><span class="line"><span class="title">forMainFrameOnly</span>: 是加入所有框架, 还是只加入主框架</span><br><span class="line">*/</span><br><span class="line">- (instance<span class="keyword">type</span>)initWithSource:(<span class="type">NSString</span> *)source injectionTime:(<span class="type">WKUserScriptInjectionTime</span>)injectionTime forMainFrameOnly:(<span class="type">BOOL</span>)forMainFrameOnly;</span><br></pre></td></tr></table></figure><h3 id="4-WKUserContentController"><a href="#4-WKUserContentController" class="headerlink" title="4.WKUserContentController"></a>4.WKUserContentController</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入JavaScript与原生交互协议</span></span><br><span class="line"><span class="comment">// JS 端可通过 window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 发送消息</span></span><br><span class="line">- (<span class="keyword">void</span>)addScriptMessageHandler:(<span class="keyword">id</span> &lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptMessageHandler name:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="comment">// 移除注入的协议, 在deinit方法中调用</span></span><br><span class="line">- (<span class="keyword">void</span>)removeScriptMessageHandlerForName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="comment">// 通过WKUserScript注入需要执行的JavaScript代码</span></span><br><span class="line">- (<span class="keyword">void</span>)addUserScript:(<span class="built_in">WKUserScript</span> *)userScript;</span><br><span class="line"><span class="comment">// 移除所有注入的JavaScript代码</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllUserScripts;</span><br></pre></td></tr></table></figure><h4 id="WKScriptMessageHandler"><a href="#WKScriptMessageHandler" class="headerlink" title="WKScriptMessageHandler"></a>WKScriptMessageHandler</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WKScriptMessage</span>类的主要属性</span><br><span class="line"><span class="comment">// 协议名称, 即上面的add方法传递的name</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">// 传递的参数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="keyword">id</span> body;</span><br></pre></td></tr></table></figure><h3 id="5-WKUIDelegate"><a href="#5-WKUIDelegate" class="headerlink" title="5.WKUIDelegate"></a>5.WKUIDelegate</h3><p>这个代理方法,主要是用来处理使用系统的弹框来替换JS中的一些弹框的,比如: 警告框, 选择框, 输入框。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> webView中弹出警告框时调用, 只能有一个按钮</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> webView webView</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> message 提示信息</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> frame 可用于区分哪个窗口调用的</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> completionHandler 警告框消失的时候调用, 回调给JS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">webView:</span>(WKWebView *)webView <span class="string">runJavaScriptAlertPanelWithMessage:</span>(NSString *)message <span class="string">initiatedByFrame:</span>(WKFrameInfo *)frame <span class="string">completionHandler:</span>(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对应js的confirm方法</span></span><br><span class="line"><span class="comment"> webView中弹出选择框时调用, 两个按钮</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> webView webView description</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> message 提示信息</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> frame 可用于区分哪个窗口调用的</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> completionHandler 确认框消失的时候调用, 回调给JS, 参数为选择结果: YES or NO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">webView:</span>(WKWebView *)webView <span class="string">runJavaScriptConfirmPanelWithMessage:</span>(NSString *)message <span class="string">initiatedByFrame:</span>(WKFrameInfo *)frame <span class="string">completionHandler:</span>(<span class="keyword">void</span> (^)(BOOL result))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 对应js的prompt方法</span></span><br><span class="line"><span class="comment"> webView中弹出输入框时调用, 两个按钮 和 一个输入框</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> webView webView description</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> prompt 提示信息</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> defaultText 默认提示文本</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> frame 可用于区分哪个窗口调用的</span></span><br><span class="line"><span class="comment"> <span class="doctag">@param</span> completionHandler 输入框消失的时候调用, 回调给JS, 参数为输入的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">webView:</span>(WKWebView *)webView <span class="string">runJavaScriptTextInputPanelWithPrompt:</span>(NSString *)prompt <span class="string">defaultText:</span>(nullable NSString *)defaultText <span class="string">initiatedByFrame:</span>(WKFrameInfo *)frame <span class="string">completionHandler:</span>(<span class="keyword">void</span> (^)(NSString * _Nullable result))completionHandler;</span><br></pre></td></tr></table></figure><h3 id="6-WKNavigationDelegate"><a href="#6-WKNavigationDelegate" class="headerlink" title="6.WKNavigationDelegate"></a>6.WKNavigationDelegate</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 决定导航的动作，通常用于处理跨域的链接能否导航。</span></span><br><span class="line"><span class="comment">// WebKit对跨域进行了安全检查限制，不允许跨域，因此我们要对不能跨域的链接单独处理。</span></span><br><span class="line"><span class="comment">// 但是，对于Safari是允许跨域的，不用这么处理。</span></span><br><span class="line"><span class="comment">// 这个是决定是否Request</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler&#123;</span><br><span class="line">    <span class="comment">//  在发送请求之前，决定是否跳转</span></span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否接收响应</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationResponse:(<span class="built_in">WKNavigationResponse</span> *)navigationResponse decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationResponsePolicy</span>))decisionHandler&#123;</span><br><span class="line">    <span class="comment">// 在收到响应后，决定是否跳转和发送请求之前那个允许配套使用</span></span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationResponsePolicyAllow</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于授权验证的API，与AFN、UIWebView的授权验证API是一样的</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *__<span class="keyword">nullable</span> credential))completionHandler&#123;</span><br><span class="line">    </span><br><span class="line">    completionHandler(<span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span> ,<span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main frame的导航开始请求时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didStartProvisionalNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当main frame接收到服务重定向时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didReceiveServerRedirectForProvisionalNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation&#123;</span><br><span class="line">    <span class="comment">// 接收到服务器跳转请求之后调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当main frame开始加载数据失败时，会回调</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFailProvisionalNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation withError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当内容开始返回时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didCommitNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation&#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当main frame导航完成时，会回调</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFinishNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation&#123;</span><br><span class="line">    <span class="comment">// 页面加载完成之后调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当main frame最后下载数据失败时，会回调</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFailNavigation:(<span class="keyword">null_unspecified</span> <span class="built_in">WKNavigation</span> *)navigation withError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当web content处理完成时，会回调</span></span><br><span class="line">- (<span class="keyword">void</span>)webViewWebContentProcessDidTerminate:(<span class="built_in">WKWebView</span> *)webView &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-WKWebsiteDataStore"><a href="#7-WKWebsiteDataStore" class="headerlink" title="7.WKWebsiteDataStore"></a>7.WKWebsiteDataStore</h3><p>WKWebsiteDataStore提供了网站所能使用的数据类型，包括 cookies，硬盘缓存，内存缓存活在一些WebSQL的数据持久化和本地持久化。可通过 WKWebViewConfiguration 类的属性 websiteDataStore 进行相关的设置。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的data store</span></span><br><span class="line">+ (<span class="built_in">WKWebsiteDataStore</span> *)defaultDataStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果为webView设置了这个data Store，则不会有数据缓存被写入文件</span></span><br><span class="line"><span class="comment">// 当需要实现隐私浏览的时候，可使用这个</span></span><br><span class="line">+ (<span class="built_in">WKWebsiteDataStore</span> *)nonPersistentDataStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否是可缓存数据的，只读</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isPersistent) <span class="built_in">BOOL</span> persistent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有可使用的数据类型</span></span><br><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)allWebsiteDataTypes;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找指定类型的缓存数据</span></span><br><span class="line"><span class="comment">// 回调的值是WKWebsiteDataRecord的集合</span></span><br><span class="line">- (<span class="keyword">void</span>)fetchDataRecordsOfTypes:(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)dataTypes completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">WKWebsiteDataRecord</span> *&gt; *))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定的纪录</span></span><br><span class="line"><span class="comment">// 这里的参数是通过上面的方法查找到的WKWebsiteDataRecord实例获取的</span></span><br><span class="line">- (<span class="keyword">void</span>)removeDataOfTypes:(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)dataTypes forDataRecords:(<span class="built_in">NSArray</span>&lt;<span class="built_in">WKWebsiteDataRecord</span> *&gt; *)dataRecords completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除某时间后修改的某类型的数据</span></span><br><span class="line">- (<span class="keyword">void</span>)removeDataOfTypes:(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)websiteDataTypes modifiedSince:(<span class="built_in">NSDate</span> *)date completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存的HTTP cookies</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">WKHTTPCookieStore</span> *httpCookieStore</span><br></pre></td></tr></table></figure><h4 id="datatypes"><a href="#datatypes" class="headerlink" title="datatypes"></a>datatypes</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 硬盘缓存</span></span><br><span class="line"><span class="built_in">WKWebsiteDataTypeDiskCache</span>,</span><br><span class="line"><span class="comment">// HTML离线web应用程序缓存</span></span><br><span class="line"><span class="built_in">WKWebsiteDataTypeOfflineWebApplicationCache</span>,</span><br><span class="line"><span class="comment">// 内存缓存</span></span><br><span class="line"><span class="built_in">WKWebsiteDataTypeMemoryCache</span>,</span><br><span class="line"><span class="comment">// 本地缓存</span></span><br><span class="line"><span class="built_in">WKWebsiteDataTypeLocalStorage</span>,</span><br><span class="line"><span class="comment">// cookies</span></span><br><span class="line"><span class="built_in">WKWebsiteDataTypeCookies</span>,</span><br><span class="line"><span class="comment">// HTML会话存储</span></span><br><span class="line"><span class="built_in">WKWebsiteDataTypeSessionStorage</span>,</span><br><span class="line"><span class="comment">//  IndexedDB 数据库</span></span><br><span class="line"><span class="built_in">WKWebsiteDataTypeIndexedDBDatabases</span>,</span><br><span class="line"><span class="comment">// WebSQL 数据库</span></span><br><span class="line"><span class="built_in">WKWebsiteDataTypeWebSQLDatabases</span></span><br></pre></td></tr></table></figure><h4 id="WKWebsiteDataRecord"><a href="#WKWebsiteDataRecord" class="headerlink" title="WKWebsiteDataRecord"></a>WKWebsiteDataRecord</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示名称, 通常是域名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *displayName;</span><br><span class="line"><span class="comment">// 包含的数据类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *dataTypes;</span><br></pre></td></tr></table></figure><h4 id="WKHTTPCookieStore"><a href="#WKHTTPCookieStore" class="headerlink" title="WKHTTPCookieStore"></a>WKHTTPCookieStore</h4><p>关于cookie, 从WKWebsiteDataStore 的实例对象的数属性httpCookieStore 可获取一个 WKHTTPCookieStore 的实例对象, 通过此对象, 我们可以对cookie进行相关的操作, 官方提供的API也不难理解:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  查找所有已存储的cookie</span></span><br><span class="line">- (<span class="keyword">void</span>)getAllCookies:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSHTTPCookie</span> *&gt; *))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存一个cookie, 保存成功后, 会走一次回调方法</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCookie:(<span class="built_in">NSHTTPCookie</span> *)cookie completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个cookie, 待删除的cookie对象可通过 'getAllCookies' 方法获取</span></span><br><span class="line">- (<span class="keyword">void</span>)deleteCookie:(<span class="built_in">NSHTTPCookie</span> *)cookie completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个观察者, 需要遵循协议 WKHTTPCookieStoreObserver,当cookie发送变化时, 会通过 WKHTTPCookieStoreObserver 的协议方法通知该观察者, 在使用完后需要移除观察者</span></span><br><span class="line"> */</span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>&lt;<span class="built_in">WKHTTPCookieStoreObserver</span>&gt;)observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>&lt;<span class="built_in">WKHTTPCookieStoreObserver</span>&gt;)observer;</span><br></pre></td></tr></table></figure><h4 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h4><p>删除指定时间的所有类型数据</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSSet</span> *websiteDataTypes = [<span class="built_in">WKWebsiteDataStore</span> allWebsiteDataTypes];</span><br><span class="line">    <span class="built_in">NSDate</span> *dateFrom = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:<span class="number">0</span>];</span><br><span class="line">    [[<span class="built_in">WKWebsiteDataStore</span> defaultDataStore] removeDataOfTypes:websiteDataTypes modifiedSince:dateFrom completionHandler:^&#123;</span><br><span class="line">        <span class="comment">// Done</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"释放"</span>);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>查找删除</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WKWebsiteDataStore</span> *dataStore = [<span class="built_in">WKWebsiteDataStore</span> defaultDataStore];</span><br><span class="line">    [dataStore fetchDataRecordsOfTypes:[<span class="built_in">WKWebsiteDataStore</span> allWebsiteDataTypes] completionHandler:^(<span class="built_in">NSArray</span>&lt;<span class="built_in">WKWebsiteDataRecord</span> *&gt; * _Nonnull records) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">WKWebsiteDataRecord</span> *record <span class="keyword">in</span> records) &#123;</span><br><span class="line">            [dataStore removeDataOfTypes:record.dataTypes forDataRecords:@[record] completionHandler:^&#123;</span><br><span class="line">                <span class="comment">// done</span></span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>查找删除特定内容</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WKWebsiteDataStore *dataStore = [WKWebsiteDataStore defaultDataStore];</span><br><span class="line">    [dataStore <span class="string">fetchDataRecordsOfTypes:</span>[WKWebsiteDataStore allWebsiteDataTypes] <span class="string">completionHandler:</span>^(NSArray&lt;WKWebsiteDataRecord *&gt; * _Nonnull records) &#123;</span><br><span class="line">        <span class="keyword">for</span> (WKWebsiteDataRecord *record <span class="keyword">in</span> records) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([record.displayName <span class="string">isEqualToString:</span>@<span class="string">"baidu"</span>]) &#123;</span><br><span class="line">                [dataStore <span class="string">removeDataOfTypes:</span>record.dataTypes <span class="string">forDataRecords:</span>@[record] <span class="string">completionHandler:</span>^&#123;</span><br><span class="line">                    <span class="comment">// done</span></span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>新增cookie</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSHTTPCookie</span> *cookie = [<span class="built_in">NSHTTPCookie</span> cookieWithProperties:@&#123;</span><br><span class="line">                                                                <span class="built_in">NSHTTPCookieName</span>: <span class="string">@"xiaoda"</span>,</span><br><span class="line">                                                                <span class="built_in">NSHTTPCookieValue</span>: <span class="string">@"2018"</span>,</span><br><span class="line">                                                                <span class="built_in">NSHTTPCookieDomain</span>: <span class="string">@"baidu.com"</span>,</span><br><span class="line">                                                                <span class="built_in">NSHTTPCookiePath</span>: <span class="string">@"/"</span>,</span><br><span class="line">                                                                <span class="built_in">NSHTTPCookieExpires</span> :   [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>]</span><br><span class="line">                                                                &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">        [web.webView.configuration.websiteDataStore.httpCookieStore setCookie:cookie completionHandler:^&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fallback on earlier versions</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取cookie</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (<span class="variable">@available</span>(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-attr">[webView.configuration.websiteDataStore.httpCookieStore getAllCookies:^(NSArray&lt;NSHTTPCookie *&gt; * _Nonnull cookies) &#123;</span></span><br><span class="line"><span class="selector-attr">            NSLog(@"%@", cookies);</span></span><br><span class="line"><span class="selector-attr">        &#125;]</span> ;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fallback on earlier versions</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从WKWebView的推出到现在，相信大家很已经了解了它相对于UIWebView的优势，加载速度快，占用内存低同时也解决了内存泄漏的问题，所以现在绝大多数的项目都已经使用了WKWebView来替代UIWebView，本文主要是对WKWebView的一些常用属性一集常用API
      
    
    </summary>
    
      <category term="iOS" scheme="http://blog.mrxiaoda.com/categories/iOS/"/>
    
    
      <category term="WKWebView" scheme="http://blog.mrxiaoda.com/tags/WKWebView/"/>
    
  </entry>
  
</feed>
